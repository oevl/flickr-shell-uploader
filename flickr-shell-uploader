#!/bin/bash

OPTIONS='t:d:a:p:f:m:s:c:h:z:n:i:'
APIKEY='beaf572d391130cbc8e7574ef1dbd1e0'
SECRET='45a4009d57890cdb'
DOTFILE="$HOME/.flickr-shell-uploader"
FROB=''
TOKEN=''
ALIASES=''
OLDALIASES=''
ALIASIDX=0

# Check we have some command line arguments at least
if [ $# -eq 0 ]; then
    cat <<EOF
Usage:
    flickr-shell-uploader [-t TITLE] [-d DESCRIPTION] [-a TAGS] [-p IS_PUBLIC] [-f IS_FRIEND] [-m IS_FAMILY] [-s SAFETY_LEVEL] [-c CONTENT_TYPE] [-h HIDDEN] [-n SUFFIX] [-x IMAGESIZE] -i <file> [-i <file> ...]

    All of the below options are optional (aside from files to upload):
    TITLE: Title of your photo.
    DESCRIPTION: Description of your photo.
    TAGS: Comma-separated list of tags for the photo (no spaces).
    IS_PUBLIC: 0 = no, 1 = yes - viewable by anyone.
    IS_FRIEND: 0 = no, 1 = yes - friends can view the photo.
    IS_FAMILY: 0 = no, 1 = yes - family can view the photo.
    SAFETY_LEVEL: 1 = safe, 2 = moderate, 3 = restricted.
    CONTENT_TYPE: 1 = photo, 2 = screenshot, 3 = other.
    HIDDEN: 1 = visible, 2 = hidden. Hides the photo from public searches.
    SUFFIX: png or PNG or jpg or JPG or jpeg or JPEG
    FILE: one file or "all". if "all" you need to specify the -n SUFFIX
    IMAGESIZE:  s  small square 75x75
                q  large square 150x150
                t  thumbnail, 100px on the longest side
                m  small, 240px on the longest side
                n  small, 320px on the longest side
                -  small, 500px on the longest side
                z  medium, 640px on the longest side
                c  medium, 800px on the longest side
                b  large, 1024px on the longest side
                o  original format, either JPG, GIF or PNG, depending on source format

    One or more files may be supplied, but the above options may only be useful for individual files!

EOF
    exit 0
fi

# Parse command line options
FILEINDEX=0
while getopts $OPTIONS name; do
    case $name in
        t)
            title="$OPTARG"
            ;;
        d)
            description="$OPTARG"
            ;;
        a)
            tags="${OPTARG/,/ }"
            ;;
        p)
            is_public="$OPTARG"
            ;;
        f)
            is_friend="$OPTARG"
            ;;
        m)
            is_family="$OPTARG"
            ;;
        s)
            safety_level="$OPTARG"
            ;;
        c)
            content_type="$OPTARG"
            ;;
        h)
            hidden="$OPTARG"
            ;;

        z)  imagesize="$OPTARG"
          ;;

        n)   suffix="$OPTARG"
          ;;

        i)  if [ $OPTARG = "all" ]
              then

              echo "Start uploading all ${suffix} files in current directory"

              find *.$suffix > filestmp.txt
              lines=$(cat filestmp.txt | wc -l)

              if [ $lines -eq 0 ]
                then
                  echo "Error: no suffix (eg. -n JPG) or no files in directory"
                else

                  for((i=1; i<=$lines; i++))
                    do
                        tmpfile="filestmp.txt"
                        FILES[$FILEINDEX]=$(sed -n "${i}p" ${tmpfile})
                        let FILEINDEX=FILEINDEX+1
                    done
              fi
                  rm -f ${tmpfile}
            else
              echo "Upload one file: ${OPTARG}"
              FILES[$FILEINDEX]="$OPTARG"
              let FILEINDEX=FILEINDEX+1
            fi
            ;;
    esac
done

require() {
    local program=$1
    local alternative=$2

    if ! which $program > /dev/null && [ "x" == "x${alternative}" ]; then
        echo "Unable to find ${program} (not installed or in PATH), which is required."
        exit 1
    elif ! which $program > /dev/null && ! which $alternative > /dev/null; then
        echo "Unable to find ${program} or alternative ${alternative} (not installed or in PATH), at least one of which is required."
        exit 1
    elif ! which $program > /dev/null; then
        program=$alternative
    fi

    # Set an alias to the command if it exists, so we don't use a shell built-in.
    # Also preserve any old aliases.
    if alias $program >/dev/null 2>&1; then
        OLDALIASES[$ALIASIDX]="$(alias $program)"
    else
        OLDALIASES[$ALIASIDX]=''
    fi
    ALIASES[$ALIASIDX]=$program
    let ALIASIDX=ALIASIDX+1
    alias $program=$(which $program)
}

# Reset aliases back to original values or unalias, if applicable.
removealiases() {
    i=0
    while [ $i -lt $ALIASIDX ]; do
        unalias ${ALIASES[$i]}
        if ! [ "x" == "x${OLDALIASES[$i]}" ]; then
            eval "${OLDALIASES[$i]}"
        fi
        let i=i+1
    done
}

loadconfig() {
    [ -f "$DOTFILE" ] && source "$DOTFILE"
}

getfrob() {
    if [ "x$FROB" == "x" ]; then
        local SIG=$(printf %b ${SECRET}api_key${APIKEY}methodflickr.auth.getFrob | md5 | awk '{print $1}')
        FROBINFO=$(curl -s "http://api.flickr.com/services/rest/?method=flickr.auth.getFrob&api_key=${APIKEY}&api_sig=${SIG}")
        local RC=$?
        if [ $RC -ne 0 ]; then
            echo "curl returned error $RC. Please consult the curl documentation for the error meaning."
            exit $RC
        fi
        if echo $FROBINFO | grep -qi "err"; then
            echo "The Flickr API returned an error while retrieving the frob. Please try again."
            exit 2
        fi
        FROB=$(echo $FROBINFO | grep -o '<frob>.*</frob>' | tr '<>' ' ' | awk '{print $2}')
        echo "FROB=$FROB" > "$DOTFILE"
    fi
}

auth() {
    if [ "x$TOKEN" == "x" ]; then
        local SIG=$(printf %b ${SECRET}api_key${APIKEY}frob${FROB}permswrite | md5 | awk '{print $1}')
        echo "Please go to the following URL: http://flickr.com/services/auth/?api_key=${APIKEY}&perms=write&frob=${FROB}&api_sig=${SIG}"
        echo ""
        echo "Then return here and press enter."
        read line
    fi
}

gettoken() {
    if [ "x$TOKEN" == "x" ]; then
        local SIG=$(printf %b ${SECRET}api_key${APIKEY}frob${FROB}methodflickr.auth.getToken | md5 | awk '{print $1}')
        TOKENINFO=$(curl -s "http://api.flickr.com/services/rest/?method=flickr.auth.getToken&api_key=${APIKEY}&frob=${FROB}&api_sig=${SIG}")
        local RC=$?
        if [ $RC -ne 0 ] || echo $TOKENINFO | grep -qi "err"; then
            echo "Was not able to successfully get the token of the confirmed frob. Try deleting $DOTFILE and starting again."
            exit 3
        fi
        TOKEN=$(echo $TOKENINFO | grep -o '<token>.*</token>' | tr '<>' ' ' | awk '{print $2}')
        echo "TOKEN=$TOKEN" >> "$DOTFILE"
    fi
}

checktoken() {
    if [ "x$TOKEN" == "x" ]; then
        echo "No token was defined."
        exit 4
    else
        local SIG=$(printf %b ${SECRET}api_key${APIKEY}auth_token${TOKEN}methodflickr.auth.checkToken | md5 | awk '{print $1}')
        TOKENINFO=$(curl -s "http://api.flickr.com/services/rest/?method=flickr.auth.checkToken&api_key=${APIKEY}&auth_token=${TOKEN}&api_sig=${SIG}")
        local RC=$?
        if [ $RC -ne 0 ] || echo $TOKENINFO | grep -qi "err"; then
            echo "Was not able to successfully check the token of the confirmed frob. Try deleting $DOTFILE and starting again."
            exit 5
        fi
        if ! echo $TOKENINFO | grep -q '<perms>write</perms>'; then
            echo "Don't have write permissions. Try deleting $DOTFILE and starting again."
            exit 6
        fi
    fi
}

upload() {
    FILE="${FILES[$1]}"
    if ! [ -f "$FILE" ]; then
        echo "$FILE does not exist"
        return
    fi

    # Make a temp file to hold the commands for uploading, with correct quoting.
    # Bash tends to make a mess of things with all the variable interpolation
    # going on here.
    TMPFILE="/tmp/flickr-shell-uploader.$$"
    printf %b "UPLOAD=\$(curl -s -F api_key=${APIKEY} -F auth_token=${TOKEN}" > $TMPFILE

    # Construct signature text and query
    local SIGTEXT="${SECRET}api_key${APIKEY}auth_token${TOKEN}"
    IFS=$(printf "\n\b")
    for i in content_type description hidden is_family is_friend is_public safety_level tags title; do
        if [ "x" != "x$(eval printf %b \$$i)" ]; then
            SIGTEXT="${SIGTEXT}${i}$(eval printf %b \$$i)"
            printf %b " -F ${i}=\"$(eval printf %b \$$i)\"" >> $TMPFILE
        fi
    done

    local SIG=$(printf %b $SIGTEXT | md5 | awk '{print $1}')
    printf %b " -F api_sig=${SIG} -F photo=@\"${FILE}\" http://api.flickr.com/services/upload/)" >> $TMPFILE
    echo -e "\nRC=\$?" >> $TMPFILE
    source $TMPFILE
    if [ $RC -ne 0 ] || echo $UPLOAD | grep -qi 'err'; then
        echo "Error uploading file $FILE"
    else
        printf %b "Uploaded $FILE"
        echo $UPLOAD | grep -o 'photoid>[[:digit:]]*<' | tr '<>' ' ' | awk '{ print " with photoid", $2 }'
        photo_id_=$(echo $UPLOAD | grep -o 'photoid>[[:digit:]]*<' | tr '<>' ' ' | awk '{ print $2 }')

        echo $(curl -s "http://api.flickr.com/services/rest/?method=flickr.photos.getInfo&api_key=${APIKEY}&photo_id=${photo_id_}") > imageinfo.txt
    photo_secret=$(grep -o ' secret="[[:alnum:]]*"' imageinfo.txt | grep -o '"[[:alnum:]]*"' | tr -d '"')
    photo_o_secret=$(grep -o 'originalsecret="[[:alnum:]]*"' imageinfo.txt | grep -o '"[[:alnum:]]*"' | tr -d '"')
    photo_farm=$(grep -o ' farm="[[:alnum:]]*"' imageinfo.txt | grep -o '"[[:alnum:]]*"' | tr -d '"')
    photo_server=$(grep -o ' server="[[:alnum:]]*"' imageinfo.txt | grep -o '"[[:alnum:]]*"' | tr -d '"')

    if [ $imagesize = "o" ]
    then
      echo "http://farm${photo_farm}.staticflickr.com/${photo_server}/${photo_id_}_${photo_o_secret}_${imagesize}.${suffix}"
      #echo "http://farm${photo_farm}.staticflickr.com/${photo_server}/${photo_id_}_${photo_o_secret}_${imagesize}.${suffix}" >> HTML_Links_${title}.txt
      echo echo "<br><img src="http://farm${photo_farm}.staticflickr.com/${photo_server}/${photo_id_}_${photo_o_secret}_${imagesize}.${suffix}" alt="TEST">" >> HTML_Links_${title}.txt
    else
      echo "http://farm${photo_farm}.staticflickr.com/${photo_server}/${photo_id_}_${photo_secret}_${imagesize}.jpg"
      #echo "http://farm${photo_farm}.staticflickr.com/${photo_server}/${photo_id_}_${photo_secret}_${imagesize}.jpg" >> HTML_Links_${title}.txt
      echo "<br><img src="http://farm${photo_farm}.staticflickr.com/${photo_server}/${photo_id_}_${photo_secret}_${imagesize}.jpg" alt="TEST">" >> HTML_Links_${title}.txt
    fi

    rm -f imageinfo.txt
    fi
    rm -f $TMPFILE
}

# We need these tools to run
require curl
require awk
require grep
require tr
# "md5" is found on OSX instead of md5sum, so provide that as an alternative.
require md5sum md5

# Load a previously saved frob, otherwise make a new one
loadconfig
getfrob

# Authenticate, and check the resulting token
auth
gettoken
checktoken

# Upload the actual files!
x=0
while [ $x -lt $FILEINDEX ]; do
    # Let the uploader just grab the filename variable itself from the array
    upload $x
    let x=x+1
done
removealiases
